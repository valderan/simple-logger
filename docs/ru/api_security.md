# Безопасность API Simple Logger

Документ описывает текущую реализацию механизмов безопасности API, расположенного в каталоге `./api`, а также практические рекомендации по работе с блокировками, белыми списками и уведомлениями.

## Авторизация и блокировка по неверным логинам

Процесс входа администратора реализован в контроллере [`authController.ts`](../../api/src/api/controllers/authController.ts). После каждой попытки авторизации фиксируется IP-адрес клиента. Если текущий IP уже заблокирован, API немедленно отвечает кодом `423 Locked` и не проверяет введённые учётные данные.【F:api/src/api/controllers/authController.ts†L8-L22】

Учёт числа неудачных попыток выполняет класс [`LoginAttempts`](../../api/src/api/utils/loginAttempts.ts). Он хранит счётчики в памяти приложения (структура `Map`). При достижении пяти подряд ошибок (`maxAttempts = 5`) для IP выставляется блокировка на один час (`LOCK_INTERVAL_MS = 60 * 60 * 1000`). Разблокировка происходит автоматически по истечении времени или сразу после успешного входа, который вызывает метод `reset` и очищает счётчик.【F:api/src/api/utils/loginAttempts.ts†L11-L38】【F:api/src/api/controllers/authController.ts†L15-L18】

Важно: данные о блокировках не сохраняются во внешнем хранилище. Перезапуск процесса Node.js или Docker-контейнера полностью очищает in-memory карту и снимает все ограничения.

### Снятие блокировки при наличии доступа к контейнеру

Если разработчик ошибся с паролем пять раз и получил блокировку, есть три варианта:

1. **Подождать один час** — блок снимется автоматически после истечения тайм-аута.
2. **Успешно авторизоваться** — верный пароль мгновенно очищает счётчик для IP.【F:api/src/api/controllers/authController.ts†L15-L18】
3. **Перезапустить API** — при наличии доступа к Docker достаточно выполнить `docker compose restart api` (или остановить/запустить контейнер вручную). In-memory данные будут очищены, так как `LoginAttempts` не хранит состояние на диске.【F:api/src/api/utils/loginAttempts.ts†L11-L38】

На данный момент API не предоставляет отдельного административного эндпоинта для ручного сброса счётчика.

## Белый список IP и связанные блокировки

Проверка адресов включена глобальным middleware [`ipWhitelist`](../../api/src/api/middlewares/ipWhitelist.ts), который срабатывает для всех маршрутов после rate limiter. Механизм работает следующим образом:

1. Каждую минуту middleware обновляет локальный кэш разрешённых адресов из коллекции MongoDB `Whitelist` (модель [`WhitelistModel`](../../api/src/api/models/Whitelist.ts)).【F:api/src/api/middlewares/ipWhitelist.ts†L4-L20】【F:api/src/api/models/Whitelist.ts†L3-L17】
2. Если белый список пуст, доступ разрешается всем клиентам (режим по умолчанию для fresh-установки).【F:api/src/api/middlewares/ipWhitelist.ts†L28-L29】
3. Локальные запросы (`127.0.0.1` и `::1`) всегда допускаются, чтобы сервис мог обращаться к себе или работать внутри одного контейнера.【F:api/src/api/middlewares/ipWhitelist.ts†L31-L33】
4. Для всех остальных IP производится проверка наличия в кэше; при отсутствии возвращается `403 Forbidden` с сообщением «IP не входит в белый список».【F:api/src/api/middlewares/ipWhitelist.ts†L34-L37】

### Где хранятся данные

Белый список хранится в коллекции MongoDB `whitelists`. Схема содержит уникальный IP и опциональное описание, а также метку времени создания записи.【F:api/src/api/models/Whitelist.ts†L3-L17】 Доступ к списку предоставляется через эндпоинты `/api/settings/whitelist` (просмотр, добавление, удаление).

### Снятие блокировки для нового проекта

Если внешний проект начал слать много логов с некорректным UUID и при этом его IP не добавлен в белый список, API будет отвечать `403 Forbidden` до тех пор, пока адрес не появится в коллекции `Whitelist`. Чтобы оперативно снять ограничение:

1. От имени администратора выполнить запрос `POST /api/settings/whitelist` и добавить IP через UI/скрипт.
2. Либо напрямую создать документ в MongoDB (`db.whitelists.insertOne({ ip: 'X.X.X.X', description: 'Project ABC' })`).

После добавления новая запись попадёт в кэш в течение минуты (TTL) — либо можно перезапустить API, чтобы очистить кэш мгновенно.【F:api/src/api/middlewares/ipWhitelist.ts†L12-L20】

### Совместимость с другими блокировками

Добавление IP в белый список **не** влияет на блокировку за неверные логины: последние хранятся отдельно в `LoginAttempts`. Если IP заблокирован из-за пяти неудачных входов, ему всё равно нужно дождаться тайм-аута или перезапуска сервиса. Напротив, если IP был заблокирован только из-за отсутствия в белом списке, то добавление в `Whitelist` автоматически вернёт доступ после обновления кэша.

### Логирование попыток доступа

Сейчас middleware белого списка не записывает системные логи при отклонении запросов. Аналогично, счётчик `LoginAttempts` не пишет события о блокировках в `logger-system`. Единственные случаи автоматического логирования — получение лога неверного формата или с неправильным UUID; тогда вызывается `writeSystemLog`, и событие сохраняется в проекте `logger-system` с тегами безопасности.【F:api/src/api/controllers/logController.ts†L29-L59】【F:api/src/api/utils/systemLogger.ts†L9-L19】

## Общие правила ограничений и защиты

Базовые уровни защиты конфигурируются в `app.ts` и включают следующие элементы:

- HTTP-заголовки безопасности с помощью `helmet` и контроль CORS через `cors`. Ограничение размера JSON-тела до 1 МБ предотвращает слишком большие payload'ы.【F:api/src/app.ts†L17-L23】
- Глобальный rate limiter (`express-rate-limit`) по умолчанию ограничивает запросы до 120 в минуту на IP и может быть изменён через `PUT /api/settings/rate-limit`. Это простая защита от DoS-атак и случайных перегрузок.【F:api/src/api/middlewares/rateLimiter.ts†L6-L11】
- Авторизационные сессии хранятся в памяти с TTL в 60 минут. Токены выдаются только после успешной проверки пары `ADMIN_USER`/`ADMIN_PASS` и автоматически очищаются при истечении срока годности.【F:api/src/api/utils/sessionStore.ts†L13-L50】
- Данные, поступающие через `/api/logs`, проходят строгую валидацию `zod`, что предотвращает сохранение произвольных структур и облегчает реакцию на ошибки интеграции.【F:api/src/api/controllers/logController.ts†L9-L76】
- Уведомления в Telegram обрабатывают анти-спам интервал и фильтрацию по тегам, предотвращая лавину сообщений при повторяющихся инцидентах.【F:api/src/telegram/notifier.ts†L20-L37】

## Пропускная способность и большие объёмы логов

При стандартной конфигурации лимитер допускает 120 запросов в минуту с одного IP. Это означает, что API **не сможет** принимать 40 000 логов в минуту (≈667 в секунду) или тем более 40 000 в секунду с одного источника: лимитер начнёт возвращать `429 Too Many Requests`. Значение можно увеличить через `/api/settings/rate-limit`, однако при больших нагрузках дополнительно потребуются архитектурные улучшения (см. отдельный список) — например, шардирование по IP или перевод приёма логов в очереди.

Кроме лимитера, следует учитывать и производительность MongoDB: каждое событие записывается синхронно через `LogModel.create`. При объёме в десятки тысяч записей в секунду потребуется оптимизация БД (батчи, репликация, выделенные ресурсы).

## Уведомления в Telegram

Настройки Telegram привязаны к каждому проекту и хранятся в документе `Project`. Для каждого получателя можно указать список тегов и анти-спам интервал (в минутах). В момент отправки логов контроллер вызывает `defaultNotifier.notify`:

1. Если Telegram-бот не настроен или уведомления отключены для проекта, сообщения не отправляются.【F:api/src/telegram/notifier.ts†L86-L99】
2. Для каждого получателя вычисляется ключ `projectUuid:chatId:tag`. Отправка разрешается, только если с последнего сообщения с этим тегом прошло не меньше `antiSpamInterval` минут.【F:api/src/telegram/notifier.ts†L91-L107】

Пример: если настроена проверка сайта раз в минуту и сервис остаётся недоступным, уведомление с тегом `PING_DOWN` уйдёт только один раз в установленный интервал. При интервале 15 минут повторные сообщения будут suppressed до истечения тайм-аута. Это защищает операторов от «шторма» уведомлений.

При наличии переменной `BOT_API_KEY` бот запускается в режиме polling, регистрирует команды меню и обрабатывает пользовательские события. Все ответы приходят на языке, выбранном пользователем через команду `/language` (доступны русский и английский).【F:api/src/telegram/notifier.ts†L72-L190】【F:api/src/telegram/notifier.ts†L285-L337】【F:api/src/telegram/notifier.ts†L395-L413】

- Сообщение `ADD:<UUID>` подписывает чат на проект после проверки UUID и наличия проекта. Бот уведомляет пользователя, предотвращает дубли и сбрасывает счётчик ошибок.【F:api/src/telegram/notifier.ts†L191-L224】
- Сообщение `DELETE:<UUID>` отменяет подписку либо сообщает, что чат ещё не привязан к проекту.【F:api/src/telegram/notifier.ts†L226-L257】
- Команда `/subscriptions` показывает список активных проектов и даёт кнопки для мгновенной отписки через callback-запросы.【F:api/src/telegram/notifier.ts†L167-L209】【F:api/src/telegram/notifier.ts†L259-L328】
- Команда `/info` возвращает `USERID` и `CHATID`, чтобы их можно было переслать администратору для ручной настройки.【F:api/src/telegram/notifier.ts†L167-L185】
- Любая попытка указать неверный UUID увеличивает счётчик ошибок. После десяти промахов бот блокирует пользователя на час и сообщает об этом в чате, а повторные обращения в течение блокировки игнорируются.【F:api/src/telegram/notifier.ts†L142-L148】【F:api/src/telegram/notifier.ts†L354-L370】

Каждое событие бота и отправка уведомлений фиксируются через `writeSystemLog`, что упрощает аудит операций в проекте `logger-system`. При невозможности записать лог ошибка выводится в консоль сервиса.【F:api/src/telegram/notifier.ts†L101-L107】【F:api/src/telegram/notifier.ts†L423-L430】

## Ответы на частые вопросы

- **Где посмотреть активные блокировки?** Прямого инструмента нет: блокировка по логинам хранится в оперативной памяти, блокировка по IP определяется содержимым коллекции `whitelists`.
- **Записываются ли системные логи при бане IP?** Нет, но система фиксирует в `logger-system` события о неверных UUID и невалидных payload'ах, что помогает отследить проблемные интеграции.【F:api/src/api/controllers/logController.ts†L29-L59】
- **Что произойдёт, если добавить заблокированный IP в белый список?** Доступ появится после обновления кэша (максимум через минуту) либо сразу после рестарта API. Для снятия блокировки за неверные логины это не поможет — нужно дождаться тайм-аута или перезапустить сервис.【F:api/src/api/middlewares/ipWhitelist.ts†L12-L37】【F:api/src/api/utils/loginAttempts.ts†L11-L38】
- **Как снять блокировку, если много логов пришло с неправильным UUID?** Добавить IP проекта в `Whitelist` и при необходимости откорректировать UUID на стороне клиента. Неверные UUID дополнительно фиксируются в системных логах, что облегчает диагностику.【F:api/src/api/controllers/logController.ts†L52-L59】

## Системы безопасности в проекте

В совокупности API использует несколько уровней защиты:

1. **Сетевой периметр**: белый список IP и rate limiter ограничивают доступ и предотвращают перегрузку. 
2. **Аутентификация**: однопользовательский вход администратора, in-memory сессии с TTL, блокировка по IP при множественных ошибках входа.
3. **Валидация данных**: схемы `zod` для логов и настроек, защита от некорректных данных.
4. **Журналирование инцидентов**: внутренний проект `logger-system` хранит предупреждения и события безопасности для анализа.【F:api/src/api/utils/systemLogger.ts†L9-L19】
5. **Уведомления**: интеграция с Telegram, анти-спам и фильтрация по тегам.
6. **Инфраструктурные меры**: `helmet`, ограничение размера тела, централизованный `morgan`-логер запросов, Docker-окружение с изолированными зависимостями.【F:api/src/app.ts†L17-L23】

Эти механизмы покрывают базовые сценарии, но не заменяют внешние меры защиты (файрволы, WAF, мониторинг базы данных).

