# Безопасность API Simple Logger

Документ описывает текущую реализацию механизмов безопасности API, расположенного в каталоге `./api`, а также практические рекомендации по работе с блокировками, белыми списками и уведомлениями.

## Авторизация и блокировка по неверным логинам

Процесс входа администратора реализован в контроллере [`authController.ts`](../../api/src/api/controllers/authController.ts). После каждой попытки авторизации фиксируется IP-адрес клиента. Если текущий IP уже заблокирован, API немедленно отвечает кодом `423 Locked` и не проверяет введённые учётные данные.【F:api/src/api/controllers/authController.ts†L8-L22】

Учёт числа неудачных попыток выполняет класс [`LoginAttempts`](../../api/src/api/utils/loginAttempts.ts). Он хранит счётчики в памяти приложения (структура `Map`). При достижении пяти подряд ошибок (`maxAttempts = 5`) для IP выставляется блокировка на один час (`LOCK_INTERVAL_MS = 60 * 60 * 1000`). Разблокировка происходит автоматически по истечении времени или сразу после успешного входа, который вызывает метод `reset` и очищает счётчик.【F:api/src/api/utils/loginAttempts.ts†L11-L38】【F:api/src/api/controllers/authController.ts†L15-L18】

Важно: данные о блокировках не сохраняются во внешнем хранилище. Перезапуск процесса Node.js или Docker-контейнера полностью очищает in-memory карту и снимает все ограничения.

### Снятие блокировки при наличии доступа к контейнеру

Если разработчик ошибся с паролем пять раз и получил блокировку, есть три варианта:

1. **Подождать один час** — блок снимется автоматически после истечения тайм-аута.
2. **Успешно авторизоваться** — верный пароль мгновенно очищает счётчик для IP.【F:api/src/api/controllers/authController.ts†L15-L18】
3. **Перезапустить API** — при наличии доступа к Docker достаточно выполнить `docker compose restart api` (или остановить/запустить контейнер вручную). In-memory данные будут очищены, так как `LoginAttempts` не хранит состояние на диске.【F:api/src/api/utils/loginAttempts.ts†L11-L38】

На данный момент API не предоставляет отдельного административного эндпоинта для ручного сброса счётчика.

## Белый список IP и обход rate limit

Глобальное middleware [`ipWhitelist`](../../api/src/api/middlewares/ipWhitelist.ts) запускается после проверки чёрного списка и до обработки маршрутов. Теперь оно не блокирует запросы напрямую, а лишь классифицирует IP-адрес, чтобы последующие компоненты могли решить, применять ли ограничение скорости.【F:api/src/api/middlewares/ipWhitelist.ts†L1-L45】

1. Каждую минуту middleware обновляет кэш нормализованных адресов из коллекции MongoDB `Whitelist` и автоматически добавляет туда IP из переменной окружения `ADMIN_IP`, если она задана.【F:api/src/api/middlewares/ipWhitelist.ts†L16-L27】【F:api/src/api/services/whitelist.ts†L5-L24】
2. Текущий IP сравнивается с кэшем; локальные адреса (`127.0.0.1`, `::1`) всегда считаются доверенными. Результат записывается в `req.isWhitelistedIp`, после чего запрос продолжает обработку дальше по цепочке.【F:api/src/api/middlewares/ipWhitelist.ts†L31-L39】
3. Rate limiter читает этот флаг и пропускает лимитирование для доверенных IP, а также для проектов с уровнями доступа `whitelist` и `docker`.【F:api/src/api/middlewares/rateLimiter.ts†L1-L35】

Все остальные адреса проходят стандартные проверки: чёрный список, глобальный rate limit и валидация данных. Удаление IP из белого списка просто возвращает его к общему лимиту.

### Где хранятся данные

Белый список хранится в коллекции MongoDB `whitelists` с уникальным IP, опциональным описанием и временем создания записи.【F:api/src/api/models/Whitelist.ts†L3-L17】 Эндпоинты `/api/settings/whitelist` возвращают расширенные объекты с полем `isProtected` для записей, управляемых через `ADMIN_IP`, и используют ту же схему для создания/обновления записей.【F:api/src/api/services/whitelist.ts†L31-L96】【F:api/src/api/controllers/settingsController.ts†L40-L74】 При добавлении или удалении запись кэша сбрасывается автоматически, поэтому изменения видны мгновенно.【F:api/src/api/middlewares/ipWhitelist.ts†L42-L45】【F:api/src/api/controllers/settingsController.ts†L47-L65】

### Переменная `ADMIN_IP`

Укажите переменную окружения `ADMIN_IP`, чтобы гарантированно разрешить административный IP. При запуске значение нормализуется и при необходимости добавляется в коллекцию, а попытка удалить эту запись через API возвращает ошибку, пока переменная существует.【F:api/src/app.ts†L31-L35】【F:api/src/api/services/whitelist.ts†L5-L86】【F:api/src/api/controllers/settingsController.ts†L55-L65】 Это защищает административный доступ от случайных изменений.

### Работа с интеграциями

Используйте белый список, чтобы исключить доверенных отправителей из-под общего rate limit. Для всех остальных правил продолжают действовать проверка токена и чёрный список. Если внешняя система временно отправляет некорректные данные (например, неверные UUID), добавьте её IP в whitelist, чтобы сохранить пропускную способность до исправления клиента; после стабилизации запись можно удалить — запросы просто вернутся к общему лимиту.

## Чёрный список IP

Для принудительных блокировок используется middleware [`blacklistGuard`](../../api/src/api/middlewares/blacklistGuard.ts). Он выполняется перед лимитером и белым списком и проверяет, не находится ли IP-адрес в коллекции MongoDB `blacklists`. Если блокировка активна (без срока или с неистекшим `expiresAt`), запрос отклоняется с кодом `403 Forbidden`, а в системный журнал `logger-system` записывается событие уровня `SECURITY` с указанием причины и маршрута обращения.【F:api/src/api/middlewares/blacklistGuard.ts†L8-L37】

Работа с коллекцией вынесена в сервис [`blacklist.ts`](../../api/src/api/services/blacklist.ts):

- все изменения (создание, обновление, удаление) логируются через `writeSystemLog`, что обеспечивает аудит административных действий;【F:api/src/api/services/blacklist.ts†L83-L160】
- актуальные блокировки кэшируются в памяти на минуту, чтобы не нагружать базу данных при каждом запросе;【F:api/src/api/services/blacklist.ts†L6-L63】
- временные блокировки автоматически удаляются после истечения срока, о чём также появляется запись `blacklist-cleanup`;【F:api/src/api/services/blacklist.ts†L24-L60】
- для бессрочных банов поле `expiresAt` остаётся `null`, при временных блоках сохраняется точная дата окончания.

Административный интерфейс предоставляет полный CRUD через эндпоинты `/api/settings/blacklist` (список и создание) и `/api/settings/blacklist/{id}` (обновление, удаление). При конфликтах по IP возвращается `409 Conflict`, что упрощает обработку ошибок на клиенте.【F:api/src/api/controllers/settingsController.ts†L42-L107】

### Совместимость с другими блокировками

Добавление IP в белый список **не** влияет на блокировку за неверные логины: последние хранятся отдельно в `LoginAttempts`. Если IP заблокирован из-за пяти неудачных входов, ему всё равно нужно дождаться тайм-аута или перезапуска сервиса. Поскольку белый список больше не отклоняет запросы, удаление записи лишь возвращает клиента к общему rate limit — постоянные ответы `403` означают наличие блокировки в чёрном списке.【F:api/src/api/utils/loginAttempts.ts†L11-L38】【F:api/src/api/middlewares/ipWhitelist.ts†L31-L39】【F:api/src/api/middlewares/blacklistGuard.ts†L8-L37】

### Логирование попыток доступа

Любые действия с чёрным списком и попытки обращения от заблокированных IP фиксируются в системном журнале. Middleware `blacklistGuard` записывает информацию о причине блокировки, HTTP-методе и запрошенном пути.【F:api/src/api/middlewares/blacklistGuard.ts†L19-L32】 Административные операции добавления, обновления и удаления блокировок, а также автоматическое снятие просроченных блоков логируются с тегами `BLACKLIST` и `SETTINGS`.【F:api/src/api/services/blacklist.ts†L24-L160】 Все системные сообщения сохраняются на английском языке для единообразного аудита. Белый список лишь помечает доверенные запросы для rate limiter и не генерирует собственных записей.【F:api/src/api/middlewares/ipWhitelist.ts†L31-L39】【F:api/src/api/middlewares/rateLimiter.ts†L1-L35】

## Общие правила ограничений и защиты

Базовые уровни защиты конфигурируются в `app.ts` и включают следующие элементы:

- HTTP-заголовки безопасности с помощью `helmet` и контроль CORS через `cors`. Ограничение размера JSON-тела до 1 МБ предотвращает слишком большие payload'ы.【F:api/src/app.ts†L17-L23】
- Глобальный rate limiter (`express-rate-limit`) по умолчанию ограничивает запросы до 120 в минуту на IP и может быть изменён через `PUT /api/settings/rate-limit`. Лимит не действует на запросы, помеченные белым списком, и на проекты с уровнями доступа `whitelist` и `docker`, поэтому доверенные сервисы не упираются в ограничение.【F:api/src/api/middlewares/ipWhitelist.ts†L31-L39】【F:api/src/api/middlewares/rateLimiter.ts†L1-L35】
- Авторизационные сессии хранятся в памяти с TTL в 60 минут. Токены выдаются только после успешной проверки пары `ADMIN_USER`/`ADMIN_PASS` и автоматически очищаются при истечении срока годности.【F:api/src/api/utils/sessionStore.ts†L13-L50】
- Данные, поступающие через `/api/logs`, проходят строгую валидацию `zod`, что предотвращает сохранение произвольных структур и облегчает реакцию на ошибки интеграции.【F:api/src/api/controllers/logController.ts†L9-L76】
- Уведомления в Telegram обрабатывают анти-спам интервал и фильтрацию по тегам, предотвращая лавину сообщений при повторяющихся инцидентах.【F:api/src/telegram/notifier.ts†L104-L127】

## Пропускная способность и большие объёмы логов

При стандартной конфигурации лимитер допускает 120 запросов в минуту с одного IP. Это означает, что API **не сможет** принимать 40 000 логов в минуту (≈667 в секунду) или тем более 40 000 в секунду с одного источника: лимитер начнёт возвращать `429 Too Many Requests`. Значение можно увеличить через `/api/settings/rate-limit`, однако при больших нагрузках дополнительно потребуются архитектурные улучшения (см. отдельный список) — например, шардирование по IP или перевод приёма логов в очереди.

Кроме лимитера, следует учитывать и производительность MongoDB: каждое событие записывается синхронно через `LogModel.create`. При объёме в десятки тысяч записей в секунду потребуется оптимизация БД (батчи, репликация, выделенные ресурсы).

## Уведомления в Telegram

Настройки Telegram привязаны к каждому проекту и хранятся в документе `Project`. Для каждого получателя можно указать список тегов и анти-спам интервал (в минутах). В момент отправки логов контроллер вызывает `defaultNotifier.notify`:

1. Если Telegram-бот не настроен или уведомления отключены для проекта, сообщения не отправляются.【F:api/src/telegram/notifier.ts†L104-L111】
2. Для каждого получателя вычисляется ключ `projectUuid:chatId:tag`. Отправка разрешается, только если с последнего сообщения с этим тегом прошло не меньше `antiSpamInterval` минут.【F:api/src/telegram/notifier.ts†L109-L125】

Пример: если настроена проверка сайта раз в минуту и сервис остаётся недоступным, уведомление с тегом `PING_DOWN` уйдёт только один раз в установленный интервал. При интервале 15 минут повторные сообщения будут suppressed до истечения тайм-аута. Это защищает операторов от «шторма» уведомлений.

Каждое сообщение начинается с явного указания проекта в формате `<Название> (<UUID>)`. Так, получатель сразу видит, какой проект сгенерировал инцидент, даже если подписан на несколько систем одновременно.

При наличии переменной `BOT_API_KEY` бот запускается в режиме polling, регистрирует команды меню и обрабатывает пользовательские события. Все ответы приходят на языке, выбранном пользователем через команду `/language` (доступны русский и английский).【F:api/src/telegram/notifier.ts†L76-L220】【F:api/src/telegram/notifier.ts†L290-L370】

- Сообщение `ADD:<UUID>` подписывает чат на проект после проверки UUID и наличия проекта. Бот уведомляет пользователя, предотвращает дубли и сбрасывает счётчик ошибок.【F:api/src/telegram/notifier.ts†L226-L259】
- Сообщение `DELETE:<UUID>` отменяет подписку либо сообщает, что чат ещё не привязан к проекту.【F:api/src/telegram/notifier.ts†L261-L292】
- Команда `/subscriptions` показывает список активных проектов и даёт кнопки для мгновенной отписки через callback-запросы.【F:api/src/telegram/notifier.ts†L201-L220】【F:api/src/telegram/notifier.ts†L290-L358】
- Команда `/info` возвращает `USERID` и `CHATID`, чтобы их можно было переслать администратору для ручной настройки.【F:api/src/telegram/notifier.ts†L201-L211】
- Любая попытка указать неверный UUID увеличивает счётчик ошибок. После десяти промахов бот блокирует пользователя на час и сообщает об этом в чате, а повторные обращения в течение блокировки игнорируются.【F:api/src/telegram/notifier.ts†L167-L180】【F:api/src/telegram/notifier.ts†L385-L399】

Каждое событие бота и отправка уведомлений фиксируются через `writeSystemLog`, что упрощает аудит операций в проекте `logger-system`. При невозможности записать лог ошибка выводится в консоль сервиса.【F:api/src/telegram/notifier.ts†L119-L125】【F:api/src/telegram/notifier.ts†L517-L528】

## Ответы на частые вопросы

- **Где посмотреть активные блокировки?** Временные и постоянные баны по IP отображаются через `GET /api/settings/blacklist`; блокировка по неверным логинам остаётся in-memory и снимается автоматически.
- **Записываются ли системные логи при бане IP?** Да: `blacklistGuard` фиксирует каждую попытку обращения заблокированного адреса, а административные действия с чёрным списком также логируются в `logger-system`.
- **Что произойдёт, если добавить заблокированный IP в белый список?** Белый список лишь отключает глобальный rate limit. Блокировки из чёрного списка и ограничения за неверные логины продолжают действовать до истечения срока или ручного удаления записи.【F:api/src/api/middlewares/ipWhitelist.ts†L31-L39】【F:api/src/api/middlewares/blacklistGuard.ts†L8-L37】【F:api/src/api/utils/loginAttempts.ts†L11-L38】
- **Как уменьшить throttling, если много логов пришло с неправильным UUID?** Исправьте UUID на стороне клиента и при необходимости добавьте IP в whitelist, чтобы временно снять ограничение скорости во время диагностики. Ошибочные UUID фиксируются в системных логах для дальнейшего анализа.【F:api/src/api/controllers/logController.ts†L64-L85】【F:api/src/api/middlewares/ipWhitelist.ts†L31-L39】

## Системы безопасности в проекте

В совокупности API использует несколько уровней защиты:

1. **Сетевой периметр**: белый список IP и rate limiter ограничивают доступ и предотвращают перегрузку. 
2. **Аутентификация**: однопользовательский вход администратора, in-memory сессии с TTL, блокировка по IP при множественных ошибках входа.
3. **Валидация данных**: схемы `zod` для логов и настроек, защита от некорректных данных.
4. **Журналирование инцидентов**: внутренний проект `logger-system` хранит предупреждения и события безопасности для анализа.【F:api/src/api/utils/systemLogger.ts†L9-L19】
5. **Уведомления**: интеграция с Telegram, анти-спам и фильтрация по тегам.
6. **Инфраструктурные меры**: `helmet`, ограничение размера тела, централизованный `morgan`-логер запросов, Docker-окружение с изолированными зависимостями.【F:api/src/app.ts†L17-L23】

Эти механизмы покрывают базовые сценарии, но не заменяют внешние меры защиты (файрволы, WAF, мониторинг базы данных).

