# Безопасность API Simple Logger

Документ описывает текущую реализацию механизмов безопасности API, расположенного в каталоге `./api`, а также практические рекомендации по работе с блокировками, белыми списками и уведомлениями.

## Авторизация и блокировка по неверным логинам

Процесс входа администратора реализован в контроллере [`authController.ts`](../../api/src/api/controllers/authController.ts). После каждой попытки авторизации фиксируется IP-адрес клиента. Если текущий IP уже заблокирован, API немедленно отвечает кодом `423 Locked` и не проверяет введённые учётные данные.【F:api/src/api/controllers/authController.ts†L8-L22】

Учёт числа неудачных попыток выполняет класс [`LoginAttempts`](../../api/src/api/utils/loginAttempts.ts). Он хранит счётчики в памяти приложения (структура `Map`). При достижении пяти подряд ошибок (`maxAttempts = 5`) для IP выставляется блокировка на один час (`LOCK_INTERVAL_MS = 60 * 60 * 1000`). Разблокировка происходит автоматически по истечении времени или сразу после успешного входа, который вызывает метод `reset` и очищает счётчик.【F:api/src/api/utils/loginAttempts.ts†L11-L38】【F:api/src/api/controllers/authController.ts†L15-L18】

Важно: данные о блокировках не сохраняются во внешнем хранилище. Перезапуск процесса Node.js или Docker-контейнера полностью очищает in-memory карту и снимает все ограничения.

### Снятие блокировки при наличии доступа к контейнеру

Если разработчик ошибся с паролем пять раз и получил блокировку, есть три варианта:

1. **Подождать один час** — блок снимется автоматически после истечения тайм-аута.
2. **Успешно авторизоваться** — верный пароль мгновенно очищает счётчик для IP.【F:api/src/api/controllers/authController.ts†L15-L18】
3. **Перезапустить API** — при наличии доступа к Docker достаточно выполнить `docker compose restart api` (или остановить/запустить контейнер вручную). In-memory данные будут очищены, так как `LoginAttempts` не хранит состояние на диске.【F:api/src/api/utils/loginAttempts.ts†L11-L38】

На данный момент API не предоставляет отдельного административного эндпоинта для ручного сброса счётчика.

## Белый список IP и связанные блокировки

Проверка адресов включена глобальным middleware [`ipWhitelist`](../../api/src/api/middlewares/ipWhitelist.ts), который срабатывает для всех маршрутов после rate limiter. Механизм работает следующим образом:

1. Каждую минуту middleware обновляет локальный кэш разрешённых адресов из коллекции MongoDB `Whitelist` (модель [`WhitelistModel`](../../api/src/api/models/Whitelist.ts)).【F:api/src/api/middlewares/ipWhitelist.ts†L4-L20】【F:api/src/api/models/Whitelist.ts†L3-L17】
2. Если белый список пуст, доступ разрешается всем клиентам (режим по умолчанию для fresh-установки).【F:api/src/api/middlewares/ipWhitelist.ts†L28-L29】
3. Локальные запросы (`127.0.0.1` и `::1`) всегда допускаются, чтобы сервис мог обращаться к себе или работать внутри одного контейнера.【F:api/src/api/middlewares/ipWhitelist.ts†L31-L33】
4. Для всех остальных IP производится проверка наличия в кэше; при отсутствии возвращается `403 Forbidden` с сообщением «IP не входит в белый список».【F:api/src/api/middlewares/ipWhitelist.ts†L34-L37】

### Где хранятся данные

Белый список хранится в коллекции MongoDB `whitelists`. Схема содержит уникальный IP и опциональное описание, а также метку времени создания записи.【F:api/src/api/models/Whitelist.ts†L3-L17】 Доступ к списку предоставляется через эндпоинты `/api/settings/whitelist` (просмотр, добавление, удаление).

### Снятие блокировки для нового проекта

Если внешний проект начал слать много логов с некорректным UUID и при этом его IP не добавлен в белый список, API будет отвечать `403 Forbidden` до тех пор, пока адрес не появится в коллекции `Whitelist`. Чтобы оперативно снять ограничение:

1. От имени администратора выполнить запрос `POST /api/settings/whitelist` и добавить IP через UI/скрипт.
2. Либо напрямую создать документ в MongoDB (`db.whitelists.insertOne({ ip: 'X.X.X.X', description: 'Project ABC' })`).

После добавления новая запись попадёт в кэш в течение минуты (TTL) — либо можно перезапустить API, чтобы очистить кэш мгновенно.【F:api/src/api/middlewares/ipWhitelist.ts†L12-L20】

### Совместимость с другими блокировками

Добавление IP в белый список **не** влияет на блокировку за неверные логины: последние хранятся отдельно в `LoginAttempts`. Если IP заблокирован из-за пяти неудачных входов, ему всё равно нужно дождаться тайм-аута или перезапуска сервиса. Напротив, если IP был заблокирован только из-за отсутствия в белом списке, то добавление в `Whitelist` автоматически вернёт доступ после обновления кэша.

### Логирование попыток доступа

Сейчас middleware белого списка не записывает системные логи при отклонении запросов. Аналогично, счётчик `LoginAttempts` не пишет события о блокировках в `logger-system`. Единственные случаи автоматического логирования — получение лога неверного формата или с неправильным UUID; тогда вызывается `writeSystemLog`, и событие сохраняется в проекте `logger-system` с тегами безопасности.【F:api/src/api/controllers/logController.ts†L29-L59】【F:api/src/api/utils/systemLogger.ts†L9-L19】

## Общие правила ограничений и защиты

Базовые уровни защиты конфигурируются в `app.ts` и включают следующие элементы:

- HTTP-заголовки безопасности с помощью `helmet` и контроль CORS через `cors`. Ограничение размера JSON-тела до 1 МБ предотвращает слишком большие payload'ы.【F:api/src/app.ts†L17-L23】
- Глобальный rate limiter (`express-rate-limit`) позволяет выполнить максимум 120 запросов в минуту с одного IP. Это простая защита от DoS-атак и случайных перегрузок.【F:api/src/api/middlewares/rateLimiter.ts†L6-L11】
- Авторизационные сессии хранятся в памяти с TTL в 60 минут. Токены выдаются только после успешной проверки пары `ADMIN_USER`/`ADMIN_PASS` и автоматически очищаются при истечении срока годности.【F:api/src/api/utils/sessionStore.ts†L13-L50】
- Данные, поступающие через `/api/logs`, проходят строгую валидацию `zod`, что предотвращает сохранение произвольных структур и облегчает реакцию на ошибки интеграции.【F:api/src/api/controllers/logController.ts†L9-L76】
- Уведомления в Telegram обрабатывают анти-спам интервал и фильтрацию по тегам, предотвращая лавину сообщений при повторяющихся инцидентах.【F:api/src/telegram/notifier.ts†L20-L37】

## Пропускная способность и большие объёмы логов

Текущий rate limiter ограничивает поток до 120 запросов в минуту с одного IP. Следовательно, API **не сможет** принимать 40 000 логов в минуту (≈667 в секунду) или тем более 40 000 в секунду с одного источника: лимитер начнёт возвращать `429 Too Many Requests`. Чтобы обрабатывать такие объёмы, потребуются доработки (см. отдельный список улучшений) — например, увеличение лимитов, шардирование по IP или переход к очередям.

Кроме лимитера, следует учитывать и производительность MongoDB: каждое событие записывается синхронно через `LogModel.create`. При объёме в десятки тысяч записей в секунду потребуется оптимизация БД (батчи, репликация, выделенные ресурсы).

## Уведомления в Telegram

Настройки Telegram привязаны к каждому проекту и хранятся в документе `Project`. Для каждого получателя можно указать список тегов и анти-спам интервал (в минутах). В момент отправки логов контроллер вызывает `defaultNotifier.notify`:

1. Если Telegram-бот не настроен или уведомления отключены для проекта, сообщения не отправляются.【F:api/src/telegram/notifier.ts†L20-L23】
2. Для каждого получателя вычисляется ключ `projectUuid:chatId:tag`. Отправка разрешается, только если с последнего сообщения с этим тегом прошло не меньше `antiSpamInterval` минут.【F:api/src/telegram/notifier.ts†L24-L37】

Пример: если настроена проверка сайта раз в минуту и сервис остаётся недоступным, уведомление с тегом `PING_DOWN` уйдёт только один раз в установленный интервал. При интервале 15 минут повторные сообщения будут suppressed до истечения тайм-аута. Это защищает операторов от «шторма» уведомлений.

## Ответы на частые вопросы

- **Где посмотреть активные блокировки?** Прямого инструмента нет: блокировка по логинам хранится в оперативной памяти, блокировка по IP определяется содержимым коллекции `whitelists`.
- **Записываются ли системные логи при бане IP?** Нет, но система фиксирует в `logger-system` события о неверных UUID и невалидных payload'ах, что помогает отследить проблемные интеграции.【F:api/src/api/controllers/logController.ts†L29-L59】
- **Что произойдёт, если добавить заблокированный IP в белый список?** Доступ появится после обновления кэша (максимум через минуту) либо сразу после рестарта API. Для снятия блокировки за неверные логины это не поможет — нужно дождаться тайм-аута или перезапустить сервис.【F:api/src/api/middlewares/ipWhitelist.ts†L12-L37】【F:api/src/api/utils/loginAttempts.ts†L11-L38】
- **Как снять блокировку, если много логов пришло с неправильным UUID?** Добавить IP проекта в `Whitelist` и при необходимости откорректировать UUID на стороне клиента. Неверные UUID дополнительно фиксируются в системных логах, что облегчает диагностику.【F:api/src/api/controllers/logController.ts†L52-L59】

## Системы безопасности в проекте

В совокупности API использует несколько уровней защиты:

1. **Сетевой периметр**: белый список IP и rate limiter ограничивают доступ и предотвращают перегрузку. 
2. **Аутентификация**: однопользовательский вход администратора, in-memory сессии с TTL, блокировка по IP при множественных ошибках входа.
3. **Валидация данных**: схемы `zod` для логов и настроек, защита от некорректных данных.
4. **Журналирование инцидентов**: внутренний проект `logger-system` хранит предупреждения и события безопасности для анализа.【F:api/src/api/utils/systemLogger.ts†L9-L19】
5. **Уведомления**: интеграция с Telegram, анти-спам и фильтрация по тегам.
6. **Инфраструктурные меры**: `helmet`, ограничение размера тела, централизованный `morgan`-логер запросов, Docker-окружение с изолированными зависимостями.【F:api/src/app.ts†L17-L23】

Эти механизмы покрывают базовые сценарии, но не заменяют внешние меры защиты (файрволы, WAF, мониторинг базы данных).

