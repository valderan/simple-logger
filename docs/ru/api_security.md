# Безопасность API Simple Logger

Документ описывает текущую реализацию механизмов безопасности API, расположенного в каталоге `./api`, а также практические рекомендации по работе с блокировками, белыми списками и уведомлениями.

## Авторизация и блокировка по неверным логинам

Процесс входа администратора реализован в контроллере [`authController.ts`](../../api/src/api/controllers/authController.ts). После каждой попытки авторизации фиксируется IP-адрес клиента. Если текущий IP уже заблокирован, API немедленно отвечает кодом `423 Locked` и не проверяет введённые учётные данные.【F:api/src/api/controllers/authController.ts†L8-L22】

Учёт числа неудачных попыток выполняет класс [`LoginAttempts`](../../api/src/api/utils/loginAttempts.ts). Он хранит счётчики в памяти приложения (структура `Map`). При достижении пяти подряд ошибок (`maxAttempts = 5`) для IP выставляется блокировка на один час (`LOCK_INTERVAL_MS = 60 * 60 * 1000`). Разблокировка происходит автоматически по истечении времени или сразу после успешного входа, который вызывает метод `reset` и очищает счётчик.【F:api/src/api/utils/loginAttempts.ts†L11-L38】【F:api/src/api/controllers/authController.ts†L15-L18】

Важно: данные о блокировках не сохраняются во внешнем хранилище. Перезапуск процесса Node.js или Docker-контейнера полностью очищает in-memory карту и снимает все ограничения.

### Снятие блокировки при наличии доступа к контейнеру

Если разработчик ошибся с паролем пять раз и получил блокировку, есть три варианта:

1. **Подождать один час** — блок снимется автоматически после истечения тайм-аута.
2. **Успешно авторизоваться** — верный пароль мгновенно очищает счётчик для IP.【F:api/src/api/controllers/authController.ts†L15-L18】
3. **Перезапустить API** — при наличии доступа к Docker достаточно выполнить `docker compose restart api` (или остановить/запустить контейнер вручную). In-memory данные будут очищены, так как `LoginAttempts` не хранит состояние на диске.【F:api/src/api/utils/loginAttempts.ts†L11-L38】

На данный момент API не предоставляет отдельного административного эндпоинта для ручного сброса счётчика.

## Белый список IP и связанные блокировки

Проверка адресов включена глобальным middleware [`ipWhitelist`](../../api/src/api/middlewares/ipWhitelist.ts), который срабатывает для всех маршрутов после проверки чёрного списка и rate limiter. Механизм работает следующим образом:

1. Каждую минуту middleware обновляет локальный кэш разрешённых адресов из коллекции MongoDB `Whitelist` (модель [`WhitelistModel`](../../api/src/api/models/Whitelist.ts)).【F:api/src/api/middlewares/ipWhitelist.ts†L4-L20】【F:api/src/api/models/Whitelist.ts†L3-L17】
2. Если белый список пуст, доступ разрешается всем клиентам (режим по умолчанию для fresh-установки).【F:api/src/api/middlewares/ipWhitelist.ts†L28-L29】
3. Локальные запросы (`127.0.0.1` и `::1`) всегда допускаются, чтобы сервис мог обращаться к себе или работать внутри одного контейнера.【F:api/src/api/middlewares/ipWhitelist.ts†L31-L33】
4. Для всех остальных IP производится проверка наличия в кэше; при отсутствии возвращается `403 Forbidden` с сообщением «IP не входит в белый список».【F:api/src/api/middlewares/ipWhitelist.ts†L34-L37】

### Где хранятся данные

Белый список хранится в коллекции MongoDB `whitelists`. Схема содержит уникальный IP и опциональное описание, а также метку времени создания записи.【F:api/src/api/models/Whitelist.ts†L3-L17】 Доступ к списку предоставляется через эндпоинты `/api/settings/whitelist` (просмотр, добавление, удаление).

### Снятие блокировки для нового проекта

Если внешний проект начал слать много логов с некорректным UUID и при этом его IP не добавлен в белый список, API будет отвечать `403 Forbidden` до тех пор, пока адрес не появится в коллекции `Whitelist`. Чтобы оперативно снять ограничение:

1. От имени администратора выполнить запрос `POST /api/settings/whitelist` и добавить IP через UI/скрипт.
2. Либо напрямую создать документ в MongoDB (`db.whitelists.insertOne({ ip: 'X.X.X.X', description: 'Project ABC' })`).

После добавления новая запись попадёт в кэш в течение минуты (TTL) — либо можно перезапустить API, чтобы очистить кэш мгновенно.【F:api/src/api/middlewares/ipWhitelist.ts†L12-L20】 Любая операция через роут `/api/settings/whitelist` автоматически сбрасывает кэш middleware, поэтому изменения начинают действовать сразу.【F:api/src/api/controllers/settingsController.ts†L25-L40】【F:api/src/api/middlewares/ipWhitelist.ts†L39-L43】

## Чёрный список IP

Для принудительных блокировок используется middleware [`blacklistGuard`](../../api/src/api/middlewares/blacklistGuard.ts). Он выполняется перед лимитером и белым списком и проверяет, не находится ли IP-адрес в коллекции MongoDB `blacklists`. Если блокировка активна (без срока или с неистекшим `expiresAt`), запрос отклоняется с кодом `403 Forbidden`, а в системный журнал `logger-system` записывается событие уровня `SECURITY` с указанием причины и маршрута обращения.【F:api/src/api/middlewares/blacklistGuard.ts†L8-L37】

Работа с коллекцией вынесена в сервис [`blacklist.ts`](../../api/src/api/services/blacklist.ts):

- все изменения (создание, обновление, удаление) логируются через `writeSystemLog`, что обеспечивает аудит административных действий;【F:api/src/api/services/blacklist.ts†L35-L104】
- актуальные блокировки кэшируются в памяти на минуту, чтобы не нагружать базу данных при каждом запросе;【F:api/src/api/services/blacklist.ts†L8-L33】
- для бессрочных банов поле `expiresAt` остаётся `null`, при временных блоках сохраняется точная дата окончания.

Административный интерфейс предоставляет полный CRUD через эндпоинты `/api/settings/blacklist` (список и создание) и `/api/settings/blacklist/{id}` (обновление, удаление). При конфликтах по IP возвращается `409 Conflict`, что упрощает обработку ошибок на клиенте.【F:api/src/api/controllers/settingsController.ts†L42-L107】

### Совместимость с другими блокировками

Добавление IP в белый список **не** влияет на блокировку за неверные логины: последние хранятся отдельно в `LoginAttempts`. Если IP заблокирован из-за пяти неудачных входов, ему всё равно нужно дождаться тайм-аута или перезапуска сервиса. Напротив, если IP был заблокирован только из-за отсутствия в белом списке, то добавление в `Whitelist` автоматически вернёт доступ после обновления кэша.

### Логирование попыток доступа

Любые действия с чёрным списком и попытки обращения от заблокированных IP фиксируются в системном журнале. Middleware `blacklistGuard` записывает информацию о причине блокировки, HTTP-методе и запрошенном пути.【F:api/src/api/middlewares/blacklistGuard.ts†L17-L35】 Административные операции добавления, обновления и удаления блокировок также попадают в журнал с тегами `BLACKLIST` и `SETTINGS`. Белый список по-прежнему не создаёт системных записей при отказе, однако его кэш автоматически сбрасывается после операций через API.【F:api/src/api/services/blacklist.ts†L35-L104】【F:api/src/api/middlewares/ipWhitelist.ts†L39-L43】

## Общие правила ограничений и защиты

Базовые уровни защиты конфигурируются в `app.ts` и включают следующие элементы:

- HTTP-заголовки безопасности с помощью `helmet` и контроль CORS через `cors`. Ограничение размера JSON-тела до 1 МБ предотвращает слишком большие payload'ы.【F:api/src/app.ts†L17-L23】
- Глобальный rate limiter (`express-rate-limit`) по умолчанию ограничивает запросы до 120 в минуту на IP и может быть изменён через `PUT /api/settings/rate-limit`. Ограничение не применяется к проектам с уровнями доступа `whitelist` и `docker`, что позволяет доверенным сервисам отправлять логи без задержек.【F:api/src/api/middlewares/rateLimiter.ts†L6-L34】
- Авторизационные сессии хранятся в памяти с TTL в 60 минут. Токены выдаются только после успешной проверки пары `ADMIN_USER`/`ADMIN_PASS` и автоматически очищаются при истечении срока годности.【F:api/src/api/utils/sessionStore.ts†L13-L50】
- Данные, поступающие через `/api/logs`, проходят строгую валидацию `zod`, что предотвращает сохранение произвольных структур и облегчает реакцию на ошибки интеграции.【F:api/src/api/controllers/logController.ts†L9-L76】
- Уведомления в Telegram обрабатывают анти-спам интервал и фильтрацию по тегам, предотвращая лавину сообщений при повторяющихся инцидентах.【F:api/src/telegram/notifier.ts†L104-L127】

## Пропускная способность и большие объёмы логов

При стандартной конфигурации лимитер допускает 120 запросов в минуту с одного IP. Это означает, что API **не сможет** принимать 40 000 логов в минуту (≈667 в секунду) или тем более 40 000 в секунду с одного источника: лимитер начнёт возвращать `429 Too Many Requests`. Значение можно увеличить через `/api/settings/rate-limit`, однако при больших нагрузках дополнительно потребуются архитектурные улучшения (см. отдельный список) — например, шардирование по IP или перевод приёма логов в очереди.

Кроме лимитера, следует учитывать и производительность MongoDB: каждое событие записывается синхронно через `LogModel.create`. При объёме в десятки тысяч записей в секунду потребуется оптимизация БД (батчи, репликация, выделенные ресурсы).

## Уведомления в Telegram

Настройки Telegram привязаны к каждому проекту и хранятся в документе `Project`. Для каждого получателя можно указать список тегов и анти-спам интервал (в минутах). В момент отправки логов контроллер вызывает `defaultNotifier.notify`:

1. Если Telegram-бот не настроен или уведомления отключены для проекта, сообщения не отправляются.【F:api/src/telegram/notifier.ts†L104-L111】
2. Для каждого получателя вычисляется ключ `projectUuid:chatId:tag`. Отправка разрешается, только если с последнего сообщения с этим тегом прошло не меньше `antiSpamInterval` минут.【F:api/src/telegram/notifier.ts†L109-L125】

Пример: если настроена проверка сайта раз в минуту и сервис остаётся недоступным, уведомление с тегом `PING_DOWN` уйдёт только один раз в установленный интервал. При интервале 15 минут повторные сообщения будут suppressed до истечения тайм-аута. Это защищает операторов от «шторма» уведомлений.

При наличии переменной `BOT_API_KEY` бот запускается в режиме polling, регистрирует команды меню и обрабатывает пользовательские события. Все ответы приходят на языке, выбранном пользователем через команду `/language` (доступны русский и английский).【F:api/src/telegram/notifier.ts†L76-L220】【F:api/src/telegram/notifier.ts†L290-L370】

- Сообщение `ADD:<UUID>` подписывает чат на проект после проверки UUID и наличия проекта. Бот уведомляет пользователя, предотвращает дубли и сбрасывает счётчик ошибок.【F:api/src/telegram/notifier.ts†L222-L255】
- Сообщение `DELETE:<UUID>` отменяет подписку либо сообщает, что чат ещё не привязан к проекту.【F:api/src/telegram/notifier.ts†L257-L288】
- Команда `/subscriptions` показывает список активных проектов и даёт кнопки для мгновенной отписки через callback-запросы.【F:api/src/telegram/notifier.ts†L201-L220】【F:api/src/telegram/notifier.ts†L290-L358】
- Команда `/info` возвращает `USERID` и `CHATID`, чтобы их можно было переслать администратору для ручной настройки.【F:api/src/telegram/notifier.ts†L201-L211】
- Любая попытка указать неверный UUID увеличивает счётчик ошибок. После десяти промахов бот блокирует пользователя на час и сообщает об этом в чате, а повторные обращения в течение блокировки игнорируются.【F:api/src/telegram/notifier.ts†L167-L180】【F:api/src/telegram/notifier.ts†L385-L399】

Каждое событие бота и отправка уведомлений фиксируются через `writeSystemLog`, что упрощает аудит операций в проекте `logger-system`. При невозможности записать лог ошибка выводится в консоль сервиса.【F:api/src/telegram/notifier.ts†L119-L125】【F:api/src/telegram/notifier.ts†L517-L528】

## Ответы на частые вопросы

- **Где посмотреть активные блокировки?** Временные и постоянные баны по IP отображаются через `GET /api/settings/blacklist`; блокировка по неверным логинам остаётся in-memory и снимается автоматически.
- **Записываются ли системные логи при бане IP?** Да: `blacklistGuard` фиксирует каждую попытку обращения заблокированного адреса, а административные действия с чёрным списком также логируются в `logger-system`.
- **Что произойдёт, если добавить заблокированный IP в белый список?** Доступ появится после обновления кэша (максимум через минуту) либо сразу после рестарта API. Для снятия блокировки за неверные логины это не поможет — нужно дождаться тайм-аута или перезапустить сервис.【F:api/src/api/middlewares/ipWhitelist.ts†L12-L37】【F:api/src/api/utils/loginAttempts.ts†L11-L38】
- **Как снять блокировку, если много логов пришло с неправильным UUID?** Добавить IP проекта в `Whitelist` и при необходимости откорректировать UUID на стороне клиента. Неверные UUID дополнительно фиксируются в системных логах, что облегчает диагностику.【F:api/src/api/controllers/logController.ts†L52-L59】

## Системы безопасности в проекте

В совокупности API использует несколько уровней защиты:

1. **Сетевой периметр**: белый список IP и rate limiter ограничивают доступ и предотвращают перегрузку. 
2. **Аутентификация**: однопользовательский вход администратора, in-memory сессии с TTL, блокировка по IP при множественных ошибках входа.
3. **Валидация данных**: схемы `zod` для логов и настроек, защита от некорректных данных.
4. **Журналирование инцидентов**: внутренний проект `logger-system` хранит предупреждения и события безопасности для анализа.【F:api/src/api/utils/systemLogger.ts†L9-L19】
5. **Уведомления**: интеграция с Telegram, анти-спам и фильтрация по тегам.
6. **Инфраструктурные меры**: `helmet`, ограничение размера тела, централизованный `morgan`-логер запросов, Docker-окружение с изолированными зависимостями.【F:api/src/app.ts†L17-L23】

Эти механизмы покрывают базовые сценарии, но не заменяют внешние меры защиты (файрволы, WAF, мониторинг базы данных).

